# 我使用LLVM的第一个语言前端教程

**要求：**本教程假设您懂C++，但不需要以前的编译器经验。

欢迎参加“我使用LLVM的第一个语言前端”教程。在这里，我们将介绍一种简单语言的实现，展示它是多么有趣和容易。本教程将让您快速上手，并展示一个使用LLVM生成代码的具体示例。

本教程介绍简单的“Kaleidoscope”语言，在几章的教程中迭代地构建它，展示它是如何随着时间的推移而构建的。这让我们可以掌握一系列语言设计和LLVM的思想。这个过程中我们会在避免大量展开前端细节的情况下进行代码讲解。我们强烈建议您*使用本项目代码*-复制一份并进行修改和实验。

**警告**：为了重点讲授编译器技术和LLVM，本教程确实*不*展示软件工程原理中的最佳实践。例如，代码无处不在地使用全局变量，不使用[visitors](http://en.wikipedia.org/wiki/Visitor_pattern)访问模式等，而是使事情变得简单，并将重点放在当前主题上。

本教程分成涵盖各个主题的独立章节，允许您根据需要跳过：

- [第1章：Kaleidoscope语言和词法分析器](LangImpl01.md)-这阐述了我们的目标和我们想要构建的基本功能。词法分析器也是构建语言解析器的第一部分，我们使用简单的C++词法分析器，它很容易理解。
- [第2章：实现解析器和AST](LangImpl02.md)-准备好词法分析器后，我们可以讨论解析技术和基本的AST构造。本教程介绍递归下降解析和运算符优先解析。
- [第3章：LLVM IR的代码生成](LangImpl03.md)-准备好AST后，我们将展示生成LLVM IR是多么容易，并展示了一种将LLVM合并到您的项目中的简单方法。
- [第4章：添加JIT和优化器支持](LangImpl04.md)-LLVM的一个伟大之处在于它对JIT编译的支持，所以我们将直接深入它，并向您展示添加JIT支持所需的3行代码。后面的章节将介绍如何生成.o文件。
- [第5章：扩展语言：控制流ControlFlow](LangImpl05.md)-随着基本语言的启动和运行，我们将如何使用控制流操作(‘if’语句和‘for’循环)来扩展它。这给了我们讨论SSA构造和控制流的机会。
- [第6章：扩展语言：用户定义的运算符](LangImpl06.md)-本章扩展了语言，允许用户定义任意的一元和二元运算符-运算符具有可分配的优先级！这允许我们构建“语言”的重要部分作为库例程。
- [第7章：扩展语言：可变变量](LangImpl07.md)-本章讨论如何添加用户定义的局部变量以及赋值操作符。这表明在llvm中构造SSA表单是多么容易：llvm*不*要求您的前端只有构造SSA表单才能使用它！
- [第8章：编译为目标文件](LangImpl08.md)-本章解释了如何获取LLVM IR并将其编译为目标文件，就像静态编译器所做的那样。
- [第9章：调试信息](LangImpl09.md)-真正的语言需要支持调试器，所以我们添加了允许在Kaleidoscope函数中设置断点、打印参数变量和调用函数的调试信息！
- [第10章：结论和其他花絮](LangImpl10.md)-本章通过讨论扩展语言的方法来结束本系列，并包括指向“特殊主题”信息的指针，如添加垃圾收集支持、异常、调试、对“意大利面堆栈（spaghetti stacks）”（译者注：spaghetti stacks也叫[Parent pointer tree](https://en.wikipedia.org/wiki/Parent_pointer_tree#:~:text=The%20term%20spaghetti%20stack%20is,bindings%20and%20other%20environmental%20features.)，是一种 N 元树数据结构，其中子节点具有指向父节点的指针）的支持等。

到本教程结束时，我们将已经编写了不到1,000行(非注释、非空白)代码行。使用这些少量代码，我们将为一种非常重要的语言构建了一个不错的小编译器，包括手工编写的词法分析器、解析器、AST，以及对代码生成的支持-包括静态和JIT！这些内容的广度极大地证明了llvm的强大，并说明了为什么它是语言设计人员和其他需要高性能语言生成（code generation）的热门目标。
