# 万花筒：结论和其他有用的LLVM花絮

：{.content local=“”}
**

## 教程结论

欢迎阅读\“[使用以下工具实现语言]的最后一章
LLVM](index.html)\“教程。在本教程的过程中，我们有
我们的小万花筒语言从一个无用的玩具成长为
成为一个半有趣(但可能还是没用)的玩具。：)

看看我们已经走了多远，它的代码是如此之少，这是很有趣的
有人了。我们构建了整个词法分析器、解析器、AST、代码生成器、
交互式运行循环(带有JIT！)，并在
独立的可执行文件-全部在1000行以下的
(非注释/非空)代码。

我们的小语言支持几个有趣的特性：它
支持用户定义的二元和一元运算符，它使用JIT
用于即时评估的编译，并且它支持几个控制流
使用SSA构造的构造。

本教程的部分想法是向您展示它是多么简单和有趣
可以定义、构建和使用语言。构建编译器
不需要是一个可怕或神秘的过程！现在你已经看到了一些
最基本的是，我强烈建议您拿起代码并破解它。
例如，尝试添加：

- **全局变量**-而全局变量有问题
在现代软件工程中的价值，它们通常在以下情况下有用
把像万花筒编译器这样的快速小技巧组合在一起
它本身。幸运的是，我们当前的设置使得添加它变得非常容易
全局变量：只需进行值查找检查，看看是否存在
未解析的变量之前在全局变量符号表中
拒绝它。要创建新的全局变量，请创建
LLVM`GlobalVariable`类。
- **类型化变量**-万花筒目前仅支持变量
类型为DOUBLE。这给语言带来了一种非常优雅的感觉，
因为只支持一种类型意味着您永远不必
指定类型。不同的语言有不同的处理方式
这。最简单的方法是要求用户为
每个变量定义，并将变量类型记录在
符号表及其值\*。
- **数组、结构、向量等**-添加类型后，您可以
开始以各种有趣的方式扩展类型系统。
简单数组非常简单，对许多不同的
申请。添加它们主要是为了学习如何使用
低层虚拟机[getelementptr](../../LangRef.html#getelementptr-instruction)
教学奏效：它是如此巧妙/不同寻常，它(有自己的特色)
常见问题](../../GetElementPtr.html)！
- **运行时标准**-我们当前的语言允许用户
访问任意外部函数，我们将其用于诸如
\“printd\”和\“putchard\”。当您扩展语言以添加
更高级别的构造，通常这些构造最有意义
如果它们被降级为调用语言提供的运行库。为
例如，如果将哈希表添加到语言中，则可能
将例程添加到运行时而不是内联是有意义的
一路上都是这样。
- **内存管理**-目前我们只能在
万花筒。能够分配堆也会很有用
内存，或者通过调用标准libc malloc/free接口
或者是垃圾收集器。如果你想用垃圾
收集，请注意LLVM完全支持[精确垃圾
集合](../../GarbageCollection.html)，包括
移动对象并需要扫描/更新堆栈。
- **异常处理支持**-LLVM支持生成[零
互操作的成本例外](../../ExceptionHandling.html)
用其他语言编译的代码。您还可以生成代码
通过隐式地使每个函数返回错误值并
正在检查。您还可以显式使用setjmp/long jmp。
去这里有很多不同的方式。
- **面向对象、泛型、数据库访问、复数
几何规划，\.** - Really, there is no end of crazy
features that you can add to the language.
- **不寻常的域**-我们一直在讨论将LLVM应用于
许多人感兴趣的领域：为
特定的语言。但是，还有许多其他域可以
使用通常不考虑的编译器技术。为
例如，LLVM已经被用来实现OpenGL图形
加速、将C++代码转换为ActionScript以及许多其他功能
可爱又聪明的东西。也许您将是第一个JIT编译
用LLVM将正则表达式解释器转换成本机代码？

玩得开心--试着做一些疯狂和不同寻常的事情。打造一门语言
就像其他人总是做的那样，比起尝试一些东西要有趣得多
有点疯狂或出人意料，看看结果如何。如果你得到
遇到困难或想要谈论它，请随时发送电子邮件到[llvm-dev邮件
list](http://lists.llvm.org/mailman/listinfo/llvm-dev)：它有很多
对语言感兴趣并经常愿意帮助的人
出去。

在我们结束本教程之前，我想谈谈一些\“技巧和
用于生成LLVM IR的技巧\“。
一些可能不是很明显的东西，但如果你想要
LLVM功能的优势。

## LLVM红外光谱的性质

关于LLVM IR表单中的代码，我们有几个常见问题
-让我们现在就把这些东西拿开，好吗？

### 目标独立性

万花筒是\“可移植语言\”的一个例子：任何程序
用万花筒编写的代码在任何目标上都会以相同的方式工作，
继续前进。许多其他语言，例如LISP，Java，
Haskell、javascript、python等(请注意，虽然这些语言
可移植，但并不是所有的库都是可移植的)。

LLVM的一个优点是它通常能够保存目标
IR中的独立性：您可以将LLVM IR
万花筒编译的程序，并在LLVM的任何目标上运行它
支持，甚至发出C代码并在LLVM的目标上编译
本身并不支持。你可以很容易地看出万花筒
编译器生成与目标无关的代码，因为它从不查询
生成代码时任何特定于目标的信息。

LLVM提供紧凑的、独立于目标的
代码的表示让很多人感到兴奋。不幸的是，
这些人通常想到的是C语言或来自C语言的一种语言
当他们询问有关语言可移植性的问题时，请与家人联系。我说
\“不幸的\”，因为真的没有办法(完全
一般)C代码可移植，而不是随身携带源代码
(当然，一般情况下，C源代码实际上也不是可移植的
- 曾经将一个非常旧的应用程序从32位移植到64位吗？)

C语言的问题(再说一次，就是它的全部通用性)就是它的工作量很大
充斥着特定于目标的假设。举一个简单的例子，
预处理器通常会破坏性地将目标独立性从
处理输入文本时的代码：

```c
#ifdef __i386__
  int X = 1;
#else
  int X = 42;
#endif
```

虽然可以设计越来越复杂的解决方案来
像这样的问题，不能完全笼统地解决，
比提供实际的源代码要好。

也就是说，C语言中有一些有趣的子集可以使其可移植。
如果您愿意将基元类型固定为固定大小(例如int=
32位，且LONG=64位)，不关心ABI与
现有的二进制文件，并愿意放弃其他一些次要功能，
您可以使用可移植的代码。这对于专门域来说是有意义的
例如内核内语言。

### 安全保障

上面的许多语言也是\“安全\”语言：它是
用Java编写的程序不可能损坏其地址空间
并使进程崩溃(假设JVM没有bug)。安全是一种
有趣的属性，需要语言设计的组合，
运行时支持，通常还有操作系统支持。

在LLVM中实现安全语言当然是可能的，但是LLVM
IR本身并不保证安全。LLVM IR允许不安全指针
强制转换、在空闲错误之后使用、缓冲区溢出以及各种其他
问题。安全需要实现为LLVM之上的一层，
方便的是，几个小组已经对此进行了调查。在网上询问
[llvm-dev邮寄list](http://lists.llvm.org/mailman/listinfo/llvm-dev)
如果您对更多细节感兴趣的话。

### 特定于语言的优化

LLVM让很多人望而却步的一件事是它不
在一个系统中解决世界上所有的问题。一个具体的抱怨是
人们认为LLVM没有能力进行高水平的
特定于语言的优化：LLVM\“丢失太多信息\”。
以下是对此的一些观察：

首先，您说得对，LLVM确实会丢失信息。
在本文中，无法区分LLVM IR中是否存在
SSA-VALUE来自ILP32计算机上的C\“int\”或C\“long\”
(除调试信息外)。两者都被向下编译为\‘I32\’值，并且
关于它的来源的信息丢失了。更普遍的问题是
这里，LLVM类型的系统使用\“结构等价\”
而不是\“名称等价\”。另一个让人惊讶的地方是
如果在高级语言中有两个类型具有相同的
结构(例如，具有单个int字段的两个不同结构)：
这些类型将编译成单个LLVM类型，它将
不可能知道它是从哪里来的。

其次，虽然LLVM确实会丢失信息，但LLVM不是固定的目标：我们
继续以多种不同的方式加强和改进它。此外
添加新功能(LLVM并不总是支持异常或调试
信息)，我们还扩展了IR以捕获以下重要信息
优化(例如自变量是符号扩展还是零扩展，
有关指针别名等的信息)。许多增强功能是
用户驱动：人们希望LLVM包含一些特定的功能，所以他们
去吧，延长一下。

第三，添加特定语言的优化是*可能而且容易*，
在如何做到这一点上，你有很多选择。作为一件微不足道的小事
例如，很容易将特定于语言的优化过程添加到
\“了解\”为一种语言编译的代码。在C语言的情况下
系列中，有一个\“知道\”标准的优化过程
C库函数。如果在main()中调用\“exit(0)\”，它知道
将其优化为\“返回0；\”是安全的，因为C指定
\‘EXIT\’函数执行此操作。

除了简单的图书馆知识之外，还可以嵌入一个
将各种其他语言特定的信息添加到LLVM IR中。如果你
如果你有特殊需要，遇到困难，请把这个话题提出来。
llvm-dev列表。在最坏的情况下，您总是可以将LLVM视为
是一个\“哑码生成器\”，并实现了高级
您希望在前端实现的特定于语言的优化
AST.

## 小贴士和小窍门

有很多有用的提示和诀窍，你在了解之后就会知道。
在LLVM上工作/与LLVM一起工作，乍一看并不明显。
让每个人都重新发现它们，这一部分将讨论其中的一些
问题。

### 实现可移植的OffsetOf/sizeof

有趣的是，如果您试图保留代码
由您的编译器\“目标独立\”生成的，是您经常
需要知道某些LLVM类型的大小或中某些字段的偏移量
一种LVM结构。例如，您可能需要将
键入分配内存的函数。

不幸的是，这在不同的目标之间可能会有很大差异：例如
指针的宽度与目标无关。但是，有一个
[使用getelementptr的聪明方法
instruction](http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt)
这样你就可以用一种便携的方式来计算了。

### 垃圾收集堆栈帧

一些语言希望显式地管理它们的堆栈框架，通常是这样
它们是垃圾收集的，或者便于实现
关闭。通常有更好的方式来实现这些功能，而不是
显式堆栈帧，但[LLVM不支持
他们，](http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt)
如果你想的话。它需要您的前端将代码转换为
[续传
Style](http://en.wikipedia.org/wiki/Continuation-passing_style)和
使用尾部调用(LLVM也支持尾部调用)。
